data N = 0 | S N;

gt 0 y = False;
gt (S x) 0 = True;
gt (S x) (S y) = gt x y;

length [] = 0;
length (x:xs) = S (length xs);

map f [] = [];
map f (x:xs) = f x : map f xs;

const f x = f;

halve 0 = 0;
halve (S 0) = S 0;
halve (S (S n)) = S (halve n);

head (x:xs) = x;
tail (x:xs) = xs;

id x = x;

take 0     xs = [];
take (S n) xs = head xs : take n (tail xs);

merge [] ys = ys;
merge (x:xs) [] = x:xs;
merge (x:xs) (y:ys) = if gt x y then y : merge (x:xs) ys else x : merge xs (y:ys);

dnc divisible solve divide combine p =
    if divisible p then combine p (map (dnc divisible solve divide combine) (divide p)) else solve p;

mdivisible [] = False;
mdivisible (x:[]) = False;
mdivisible (x:x':xs) = True;

mdivide xs = mdivide' (halve (length xs)) xs;
mdivide' n xs = take n xs : drop n xs : [];

mcombine (xs:ys:[]) = merge xs ys;

mergesort xs = dnc mdivisible id mdivide (const mcombine) xs;
